#!/usr/bin/env node

/**
 * Simple script to generate dark mode CSS using DarkReader
 * Generates darkmode.css and darkmode.min.css in resources folder
 * 
 * Prerequisites:
 *   npm install puppeteer
 * 
 * Usage:
 *   node generate_darkmode.js [url]
 *   
 * Examples:
 *   node generate_darkmode.js
 *   node generate_darkmode.js http://localhost:8000
 */

const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');

// Configuration
const DEFAULT_URL = 'http://localhost:8000';
const OUTPUT_DIR = '../resources';
const OUTPUT_FILE = 'darkmode.css';
const DARKREADER_CDN = 'https://cdn.jsdelivr.net/npm/darkreader@4.9.109/darkreader.min.js';

async function generateDarkModeCSS(url = DEFAULT_URL) {
    console.log(`üåô Generating dark mode CSS for ${url}...`);
    
    const browser = await puppeteer.launch({
        headless: 'new',
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    try {
        const page = await browser.newPage();
        
        // Set viewport
        await page.setViewport({ width: 1920, height: 1080 });
        
        console.log(`üìÑ Loading page: ${url}`);
        await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
        
        console.log('üíâ Injecting DarkReader...');
        await page.addScriptTag({ url: DARKREADER_CDN });
        
        // Wait for DarkReader to load
        await page.waitForFunction('typeof DarkReader !== "undefined"', { timeout: 10000 });
        
        console.log('üé® Enabling DarkReader and generating CSS...');
        
        // Enable DarkReader with default settings and export CSS
        const css = await page.evaluate(() => {
            return new Promise((resolve) => {
                // Enable DarkReader with default settings
                DarkReader.enable();
                
                // Wait for styles to be applied
                setTimeout(async () => {
                    // Export the generated CSS
                    const css = await DarkReader.exportGeneratedCSS();
                    resolve(css);
                }, 2000);
            });
        });
        
        // Ensure output directory exists
        const outputPath = path.join(__dirname, OUTPUT_DIR);
        if (!fs.existsSync(outputPath)) {
            fs.mkdirSync(outputPath, { recursive: true });
        }
        
        // Add header comment
        const header = `/* 
 * Dark Mode CSS generated by DarkReader
 * Generated automatically using darkmode_generator/generate_darkmode.js
 * To regenerate: cd darkmode_generator && node generate_darkmode.js
 * Generated at: ${new Date().toISOString()}
 */

`;
        
        // Save full CSS
        const fullPath = path.join(outputPath, OUTPUT_FILE);
        fs.writeFileSync(fullPath, header + css, 'utf-8');
        console.log(`‚úÖ Dark mode CSS saved to: ${OUTPUT_FILE}`);
        console.log(`üìè CSS size: ${css.length.toLocaleString()} characters`);
        
        // Generate minified version
        const minifiedCSS = css
            .replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
            .replace(/\n/g, '')
            .replace(/\s{2,}/g, ' ')
            .replace(/:\s/g, ':')
            .replace(/;\s/g, ';')
            .replace(/{\s/g, '{')
            .replace(/\s}/g, '}')
            .replace(/,\s/g, ',');
        
        const minPath = path.join(outputPath, OUTPUT_FILE.replace('.css', '.min.css'));
        fs.writeFileSync(minPath, header.replace(/\n/g, ' ') + minifiedCSS, 'utf-8');
        console.log(`üóúÔ∏è  Minified CSS saved to: darkmode.min.css`);
        console.log(`üìè Minified size: ${minifiedCSS.length.toLocaleString()} characters`);
        
        // Calculate compression ratio
        const ratio = ((1 - minifiedCSS.length / css.length) * 100).toFixed(1);
        console.log(`üìä Compression ratio: ${ratio}% smaller`);
        
    } catch (error) {
        console.error(`‚ùå Error generating dark mode CSS: ${error.message}`);
        process.exit(1);
    } finally {
        await browser.close();
    }
}

async function main() {
    const args = process.argv.slice(2);
    
    // Parse URL from arguments
    const url = args[0] || DEFAULT_URL;
    
    // Check if puppeteer is installed
    try {
        require.resolve('puppeteer');
    } catch (e) {
        console.error('‚ùå Error: puppeteer is not installed');
        console.log('Install it with: npm install puppeteer');
        console.log('Or run: cd darkmode_generator && npm install');
        process.exit(1);
    }
    
    // Check if server is running
    try {
        const response = await fetch(url);
        if (!response.ok) {
            console.warn(`‚ö†Ô∏è  Warning: Server returned status ${response.status}`);
        }
    } catch (error) {
        console.warn(`‚ö†Ô∏è  Warning: Cannot connect to ${url}`);
        console.log('Make sure the Django server is running:');
        console.log('  python3 manage.py runserver');
        console.log('\nContinuing anyway...\n');
    }
    
    try {
        await generateDarkModeCSS(url);
        console.log('\n‚ú® Done! Dark mode CSS generated successfully.');
    } catch (error) {
        console.error(`\n‚ùå Failed: ${error.message}`);
        process.exit(1);
    }
}

// Run the script
if (require.main === module) {
    main().catch(console.error);
}

module.exports = { generateDarkModeCSS };